// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///* defined by Bosch
public enum SignalIdentifier: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case undefined // = 0
  case iaq // = 1
  case staticIaq // = 2
  case co2Eq // = 3
  case breathVocEq // = 4
  case rawTemperature // = 6
  case rawPressure // = 7
  case rawHumidity // = 8
  case rawGas // = 9
  case stabilizationStatus // = 12
  case runInStatus // = 13
  case sensorHeatCompenTemp // = 14
  case heatCompenHumid // = 15
  case gasPercentage // = 21
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .iaq
    case 2: self = .staticIaq
    case 3: self = .co2Eq
    case 4: self = .breathVocEq
    case 6: self = .rawTemperature
    case 7: self = .rawPressure
    case 8: self = .rawHumidity
    case 9: self = .rawGas
    case 12: self = .stabilizationStatus
    case 13: self = .runInStatus
    case 14: self = .sensorHeatCompenTemp
    case 15: self = .heatCompenHumid
    case 21: self = .gasPercentage
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .iaq: return 1
    case .staticIaq: return 2
    case .co2Eq: return 3
    case .breathVocEq: return 4
    case .rawTemperature: return 6
    case .rawPressure: return 7
    case .rawHumidity: return 8
    case .rawGas: return 9
    case .stabilizationStatus: return 12
    case .runInStatus: return 13
    case .sensorHeatCompenTemp: return 14
    case .heatCompenHumid: return 15
    case .gasPercentage: return 21
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SignalIdentifier: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SignalIdentifier] = [
    .undefined,
    .iaq,
    .staticIaq,
    .co2Eq,
    .breathVocEq,
    .rawTemperature,
    .rawPressure,
    .rawHumidity,
    .rawGas,
    .stabilizationStatus,
    .runInStatus,
    .sensorHeatCompenTemp,
    .heatCompenHumid,
    .gasPercentage,
  ]
}

#endif  // swift(>=4.2)

///* defined by Bosch
public enum SensorAccuracy: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unreliable // = 0
  case lowAccuracy // = 1
  case mediumAccuracy // = 2
  case highAccuracy // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unreliable
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unreliable
    case 1: self = .lowAccuracy
    case 2: self = .mediumAccuracy
    case 3: self = .highAccuracy
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unreliable: return 0
    case .lowAccuracy: return 1
    case .mediumAccuracy: return 2
    case .highAccuracy: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SensorAccuracy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [SensorAccuracy] = [
    .unreliable,
    .lowAccuracy,
    .mediumAccuracy,
    .highAccuracy,
  ]
}

#endif  // swift(>=4.2)

public enum MicSampleFreq: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case sampleRate8000 // = 0
  case sampleRate11025 // = 1
  case sampleRate16000 // = 2
  case sampleRate22500 // = 3
  case sampleRate24000 // = 4
  case sampleRate32000 // = 5
  case sampleRate44100 // = 6
  case sampleRate48000 // = 7
  case sampleRate96000 // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .sampleRate8000
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sampleRate8000
    case 1: self = .sampleRate11025
    case 2: self = .sampleRate16000
    case 3: self = .sampleRate22500
    case 4: self = .sampleRate24000
    case 5: self = .sampleRate32000
    case 6: self = .sampleRate44100
    case 7: self = .sampleRate48000
    case 8: self = .sampleRate96000
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .sampleRate8000: return 0
    case .sampleRate11025: return 1
    case .sampleRate16000: return 2
    case .sampleRate22500: return 3
    case .sampleRate24000: return 4
    case .sampleRate32000: return 5
    case .sampleRate44100: return 6
    case .sampleRate48000: return 7
    case .sampleRate96000: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MicSampleFreq: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [MicSampleFreq] = [
    .sampleRate8000,
    .sampleRate11025,
    .sampleRate16000,
    .sampleRate22500,
    .sampleRate24000,
    .sampleRate32000,
    .sampleRate44100,
    .sampleRate48000,
    .sampleRate96000,
  ]
}

#endif  // swift(>=4.2)

public enum MicGain: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case gain60Db // = 0
  case gain57Db // = 1
  case gain54Db // = 2
  case gain51Db // = 3
  case gain48Db // = 4
  case gain45Db // = 5
  case gain42Db // = 6
  case gain39Db // = 7
  case gain36Db // = 8
  case gain33Db // = 9
  case gain30Db // = 10
  case gain27Db // = 11
  case gain24Db // = 12
  case gain21Db // = 13
  case gain18Db // = 14
  case gain15Db // = 15
  case gain12Db // = 16
  case gain9Db // = 17
  case gain6Db // = 18
  case gain3Db // = 19
  case gain0Db // = 20
  case gainNeg3Db // = 21
  case gainNeg6Db // = 22
  case gainNeg9Db // = 23
  case gainNeg12Db // = 24
  case gainNeg15Db // = 25
  case UNRECOGNIZED(Int)

  public init() {
    self = .gain60Db
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .gain60Db
    case 1: self = .gain57Db
    case 2: self = .gain54Db
    case 3: self = .gain51Db
    case 4: self = .gain48Db
    case 5: self = .gain45Db
    case 6: self = .gain42Db
    case 7: self = .gain39Db
    case 8: self = .gain36Db
    case 9: self = .gain33Db
    case 10: self = .gain30Db
    case 11: self = .gain27Db
    case 12: self = .gain24Db
    case 13: self = .gain21Db
    case 14: self = .gain18Db
    case 15: self = .gain15Db
    case 16: self = .gain12Db
    case 17: self = .gain9Db
    case 18: self = .gain6Db
    case 19: self = .gain3Db
    case 20: self = .gain0Db
    case 21: self = .gainNeg3Db
    case 22: self = .gainNeg6Db
    case 23: self = .gainNeg9Db
    case 24: self = .gainNeg12Db
    case 25: self = .gainNeg15Db
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .gain60Db: return 0
    case .gain57Db: return 1
    case .gain54Db: return 2
    case .gain51Db: return 3
    case .gain48Db: return 4
    case .gain45Db: return 5
    case .gain42Db: return 6
    case .gain39Db: return 7
    case .gain36Db: return 8
    case .gain33Db: return 9
    case .gain30Db: return 10
    case .gain27Db: return 11
    case .gain24Db: return 12
    case .gain21Db: return 13
    case .gain18Db: return 14
    case .gain15Db: return 15
    case .gain12Db: return 16
    case .gain9Db: return 17
    case .gain6Db: return 18
    case .gain3Db: return 19
    case .gain0Db: return 20
    case .gainNeg3Db: return 21
    case .gainNeg6Db: return 22
    case .gainNeg9Db: return 23
    case .gainNeg12Db: return 24
    case .gainNeg15Db: return 25
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MicGain: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [MicGain] = [
    .gain60Db,
    .gain57Db,
    .gain54Db,
    .gain51Db,
    .gain48Db,
    .gain45Db,
    .gain42Db,
    .gain39Db,
    .gain36Db,
    .gain33Db,
    .gain30Db,
    .gain27Db,
    .gain24Db,
    .gain21Db,
    .gain18Db,
    .gain15Db,
    .gain12Db,
    .gain9Db,
    .gain6Db,
    .gain3Db,
    .gain0Db,
    .gainNeg3Db,
    .gainNeg6Db,
    .gainNeg9Db,
    .gainNeg12Db,
    .gainNeg15Db,
  ]
}

#endif  // swift(>=4.2)

public enum MicBitResolution: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case bitRes8 // = 0
  case bitRes16 // = 1
  case bitRes24 // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .bitRes8
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .bitRes8
    case 1: self = .bitRes16
    case 2: self = .bitRes24
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .bitRes8: return 0
    case .bitRes16: return 1
    case .bitRes24: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MicBitResolution: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [MicBitResolution] = [
    .bitRes8,
    .bitRes16,
    .bitRes24,
  ]
}

#endif  // swift(>=4.2)

public enum CompressionType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case opus // = 0
  case flac // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .opus
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .opus
    case 1: self = .flac
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .opus: return 0
    case .flac: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CompressionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CompressionType] = [
    .opus,
    .flac,
  ]
}

#endif  // swift(>=4.2)

public struct PacketHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var systemUid: UInt32 = 0

  public var msFromStart: UInt32 = 0

  public var epoch: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SimpleSensorReading {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var index: UInt32 = 0

  public var timestampUnix: UInt32 = 0

  public var temperature: Float = 0

  public var humidity: Float = 0

  public var co2: Float = 0

  public var lightLevel: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SensorReading {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var packetIndex: UInt32 = 0

  public var samplePeriod: UInt32 = 0

  public var payload: [SensorReading.Payload] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var timestampSensor: UInt64 = 0

    public var timestampUnix: UInt64 = 0

    public var timestampMsFromStart: UInt32 = 0

    public var signal: Float = 0

    public var signalDimensions: UInt32 = 0

    public var sensorID: SignalIdentifier = .undefined

    public var accuracy: SensorAccuracy = .unreliable

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct SensorConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enableTemperature: Bool = false

  public var enableHumidity: Bool = false

  public var enableGas: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SDCardState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var detected: Bool = false

  public var spaceRemaining: UInt64 = 0

  public var estimatedRemainingRecordingTime: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MarkState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///bool beep_enabled = 1;
  public var markNumber: UInt32 = 0

  public var timestampUnix: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MarkPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///optional string annotation = 1 [(nanopb).max_length = 50];// throttle max character count (e.g., 50)
  public var annotation: String {
    get {return _annotation ?? String()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  public var hasAnnotation: Bool {return self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotation() {self._annotation = nil}

  public var beepEnabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotation: String? = nil
}

public struct BatteryState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var charging: Bool = false

  public var voltage: Float = 0

  public var percentage: Float {
    get {return _percentage ?? 0}
    set {_percentage = newValue}
  }
  /// Returns true if `percentage` has been explicitly set.
  public var hasPercentage: Bool {return self._percentage != nil}
  /// Clears the value of `percentage`. Subsequent reads from it will return its default value.
  public mutating func clearPercentage() {self._percentage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _percentage: Float? = nil
}

public struct Device {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: UInt32 = 0

  public var range: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SystemInfoPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var simpleSensorReading: SimpleSensorReading {
    get {return _simpleSensorReading ?? SimpleSensorReading()}
    set {_simpleSensorReading = newValue}
  }
  /// Returns true if `simpleSensorReading` has been explicitly set.
  public var hasSimpleSensorReading: Bool {return self._simpleSensorReading != nil}
  /// Clears the value of `simpleSensorReading`. Subsequent reads from it will return its default value.
  public mutating func clearSimpleSensorReading() {self._simpleSensorReading = nil}

  public var deviceRecording: Bool = false

  public var sdcardState: SDCardState {
    get {return _sdcardState ?? SDCardState()}
    set {_sdcardState = newValue}
  }
  /// Returns true if `sdcardState` has been explicitly set.
  public var hasSdcardState: Bool {return self._sdcardState != nil}
  /// Clears the value of `sdcardState`. Subsequent reads from it will return its default value.
  public mutating func clearSdcardState() {self._sdcardState = nil}

  public var markState: MarkState {
    get {return _markState ?? MarkState()}
    set {_markState = newValue}
  }
  /// Returns true if `markState` has been explicitly set.
  public var hasMarkState: Bool {return self._markState != nil}
  /// Clears the value of `markState`. Subsequent reads from it will return its default value.
  public mutating func clearMarkState() {self._markState = nil}

  public var batteryState: BatteryState {
    get {return _batteryState ?? BatteryState()}
    set {_batteryState = newValue}
  }
  /// Returns true if `batteryState` has been explicitly set.
  public var hasBatteryState: Bool {return self._batteryState != nil}
  /// Clears the value of `batteryState`. Subsequent reads from it will return its default value.
  public mutating func clearBatteryState() {self._batteryState = nil}

  public var discoveredDevices: [Device] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _simpleSensorReading: SimpleSensorReading? = nil
  fileprivate var _sdcardState: SDCardState? = nil
  fileprivate var _markState: MarkState? = nil
  fileprivate var _batteryState: BatteryState? = nil
}

public struct AudioCompression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enabled: Bool = false

  public var compressionType: CompressionType = .opus

  public var compressionFactor: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct AudioConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channel1: Bool = false

  public var channel2: Bool = false

  public var sampleFreq: MicSampleFreq = .sampleRate8000

  public var micGain: MicGain = .gain60Db

  public var bitResolution: MicBitResolution = .bitRes8

  public var audioCompression: AudioCompression {
    get {return _audioCompression ?? AudioCompression()}
    set {_audioCompression = newValue}
  }
  /// Returns true if `audioCompression` has been explicitly set.
  public var hasAudioCompression: Bool {return self._audioCompression != nil}
  /// Clears the value of `audioCompression`. Subsequent reads from it will return its default value.
  public mutating func clearAudioCompression() {self._audioCompression = nil}

  public var estimatedRecordTime: Float = 0

  public var freeRunMode: Bool = false

  public var chirpEnable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _audioCompression: AudioCompression? = nil
}

public struct ScheduleConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sunday: Bool = false

  public var monday: Bool = false

  public var tuesday: Bool = false

  public var wednesday: Bool = false

  public var thursday: Bool = false

  public var friday: Bool = false

  public var saturday: Bool = false

  public var startHour: UInt32 = 0

  public var startMinute: UInt32 = 0

  public var stopHour: UInt32 = 0

  public var stopMinute: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct LowPowerConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lowPowerMode: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CameraControl {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pairWithNearbyCameras: Bool = false

  public var wakeupCameras: Bool = false

  public var capture: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct DeviceUID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var addr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct NetworkState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var numberOfDiscoveredDevices: UInt32 = 0

  public var discoveredDeviceUid: [DeviceUID] = []

  public var channel: UInt32 = 0

  public var panID: UInt32 = 0

  public var slaveSync: Bool = false

  public var masterNode: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ConfigPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var audioConfig: AudioConfig {
    get {return _storage._audioConfig ?? AudioConfig()}
    set {_uniqueStorage()._audioConfig = newValue}
  }
  /// Returns true if `audioConfig` has been explicitly set.
  public var hasAudioConfig: Bool {return _storage._audioConfig != nil}
  /// Clears the value of `audioConfig`. Subsequent reads from it will return its default value.
  public mutating func clearAudioConfig() {_uniqueStorage()._audioConfig = nil}

  public var scheduleConfig: [ScheduleConfig] {
    get {return _storage._scheduleConfig}
    set {_uniqueStorage()._scheduleConfig = newValue}
  }

  public var sensorConfig: SensorConfig {
    get {return _storage._sensorConfig ?? SensorConfig()}
    set {_uniqueStorage()._sensorConfig = newValue}
  }
  /// Returns true if `sensorConfig` has been explicitly set.
  public var hasSensorConfig: Bool {return _storage._sensorConfig != nil}
  /// Clears the value of `sensorConfig`. Subsequent reads from it will return its default value.
  public mutating func clearSensorConfig() {_uniqueStorage()._sensorConfig = nil}

  public var lowPowerConfig: LowPowerConfig {
    get {return _storage._lowPowerConfig ?? LowPowerConfig()}
    set {_uniqueStorage()._lowPowerConfig = newValue}
  }
  /// Returns true if `lowPowerConfig` has been explicitly set.
  public var hasLowPowerConfig: Bool {return _storage._lowPowerConfig != nil}
  /// Clears the value of `lowPowerConfig`. Subsequent reads from it will return its default value.
  public mutating func clearLowPowerConfig() {_uniqueStorage()._lowPowerConfig = nil}

  public var networkState: NetworkState {
    get {return _storage._networkState ?? NetworkState()}
    set {_uniqueStorage()._networkState = newValue}
  }
  /// Returns true if `networkState` has been explicitly set.
  public var hasNetworkState: Bool {return _storage._networkState != nil}
  /// Clears the value of `networkState`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkState() {_uniqueStorage()._networkState = nil}

  public var enableRecording: Bool {
    get {return _storage._enableRecording}
    set {_uniqueStorage()._enableRecording = newValue}
  }

  public var enableLed: Bool {
    get {return _storage._enableLed}
    set {_uniqueStorage()._enableLed = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct PeerAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Encoded as u16.
  public var panID: UInt32 = 0

  /// 2 or 8 bytes (short / extended).
  public var address: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UWB_Range {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var openthreadUid: DeviceUID {
    get {return _openthreadUid ?? DeviceUID()}
    set {_openthreadUid = newValue}
  }
  /// Returns true if `openthreadUid` has been explicitly set.
  public var hasOpenthreadUid: Bool {return self._openthreadUid != nil}
  /// Clears the value of `openthreadUid`. Subsequent reads from it will return its default value.
  public mutating func clearOpenthreadUid() {self._openthreadUid = nil}

  public var systemUid: UInt32 = 0

  public var uwbAddr: PeerAddress {
    get {return _uwbAddr ?? PeerAddress()}
    set {_uwbAddr = newValue}
  }
  /// Returns true if `uwbAddr` has been explicitly set.
  public var hasUwbAddr: Bool {return self._uwbAddr != nil}
  /// Clears the value of `uwbAddr`. Subsequent reads from it will return its default value.
  public mutating func clearUwbAddr() {self._uwbAddr = nil}

  public var range: UInt32 = 0

  public var stdDev: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _openthreadUid: DeviceUID? = nil
  fileprivate var _uwbAddr: PeerAddress? = nil
}

public struct UWB_Info {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var openthreadUid: DeviceUID {
    get {return _openthreadUid ?? DeviceUID()}
    set {_openthreadUid = newValue}
  }
  /// Returns true if `openthreadUid` has been explicitly set.
  public var hasOpenthreadUid: Bool {return self._openthreadUid != nil}
  /// Clears the value of `openthreadUid`. Subsequent reads from it will return its default value.
  public mutating func clearOpenthreadUid() {self._openthreadUid = nil}

  public var systemUid: UInt32 = 0

  public var uwbAddr: PeerAddress {
    get {return _uwbAddr ?? PeerAddress()}
    set {_uwbAddr = newValue}
  }
  /// Returns true if `uwbAddr` has been explicitly set.
  public var hasUwbAddr: Bool {return self._uwbAddr != nil}
  /// Clears the value of `uwbAddr`. Subsequent reads from it will return its default value.
  public mutating func clearUwbAddr() {self._uwbAddr = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _openthreadUid: DeviceUID? = nil
  fileprivate var _uwbAddr: PeerAddress? = nil
}

public struct UWB_Packet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startRanging: Bool = false

  public var turnOnUwb: Bool = false

  public var ranges: [UWB_Range] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SpecialFunction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: SpecialFunction.OneOf_Payload? = nil

  public var formatSdcard: Bool {
    get {
      if case .formatSdcard(let v)? = payload {return v}
      return false
    }
    set {payload = .formatSdcard(newValue)}
  }

  public var cameraControl: CameraControl {
    get {
      if case .cameraControl(let v)? = payload {return v}
      return CameraControl()
    }
    set {payload = .cameraControl(newValue)}
  }

  public var uwbPacket: UWB_Packet {
    get {
      if case .uwbPacket(let v)? = payload {return v}
      return UWB_Packet()
    }
    set {payload = .uwbPacket(newValue)}
  }

  public var openthreadSyncTime: Bool {
    get {
      if case .openthreadSyncTime(let v)? = payload {return v}
      return false
    }
    set {payload = .openthreadSyncTime(newValue)}
  }

  public var magCalibration: Bool {
    get {
      if case .magCalibration(let v)? = payload {return v}
      return false
    }
    set {payload = .magCalibration(newValue)}
  }

  public var slaveReqConfig: Bool {
    get {
      if case .slaveReqConfig(let v)? = payload {return v}
      return false
    }
    set {payload = .slaveReqConfig(newValue)}
  }

  public var timestamp: UInt32 {
    get {
      if case .timestamp(let v)? = payload {return v}
      return 0
    }
    set {payload = .timestamp(newValue)}
  }

  public var dfuMode: Bool {
    get {
      if case .dfuMode(let v)? = payload {return v}
      return false
    }
    set {payload = .dfuMode(newValue)}
  }

  public var uwbInfo: UWB_Info {
    get {
      if case .uwbInfo(let v)? = payload {return v}
      return UWB_Info()
    }
    set {payload = .uwbInfo(newValue)}
  }

  public var resetConfig: Bool {
    get {
      if case .resetConfig(let v)? = payload {return v}
      return false
    }
    set {payload = .resetConfig(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case formatSdcard(Bool)
    case cameraControl(CameraControl)
    case uwbPacket(UWB_Packet)
    case openthreadSyncTime(Bool)
    case magCalibration(Bool)
    case slaveReqConfig(Bool)
    case timestamp(UInt32)
    case dfuMode(Bool)
    case uwbInfo(UWB_Info)
    case resetConfig(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: SpecialFunction.OneOf_Payload, rhs: SpecialFunction.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.formatSdcard, .formatSdcard): return {
        guard case .formatSdcard(let l) = lhs, case .formatSdcard(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cameraControl, .cameraControl): return {
        guard case .cameraControl(let l) = lhs, case .cameraControl(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uwbPacket, .uwbPacket): return {
        guard case .uwbPacket(let l) = lhs, case .uwbPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.openthreadSyncTime, .openthreadSyncTime): return {
        guard case .openthreadSyncTime(let l) = lhs, case .openthreadSyncTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.magCalibration, .magCalibration): return {
        guard case .magCalibration(let l) = lhs, case .magCalibration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.slaveReqConfig, .slaveReqConfig): return {
        guard case .slaveReqConfig(let l) = lhs, case .slaveReqConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timestamp, .timestamp): return {
        guard case .timestamp(let l) = lhs, case .timestamp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dfuMode, .dfuMode): return {
        guard case .dfuMode(let l) = lhs, case .dfuMode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uwbInfo, .uwbInfo): return {
        guard case .uwbInfo(let l) = lhs, case .uwbInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resetConfig, .resetConfig): return {
        guard case .resetConfig(let l) = lhs, case .resetConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Packet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: PacketHeader {
    get {return _storage._header ?? PacketHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {_uniqueStorage()._header = nil}

  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var systemInfoPacket: SystemInfoPacket {
    get {
      if case .systemInfoPacket(let v)? = _storage._payload {return v}
      return SystemInfoPacket()
    }
    set {_uniqueStorage()._payload = .systemInfoPacket(newValue)}
  }

  public var markPacket: MarkPacket {
    get {
      if case .markPacket(let v)? = _storage._payload {return v}
      return MarkPacket()
    }
    set {_uniqueStorage()._payload = .markPacket(newValue)}
  }

  public var configPacket: ConfigPacket {
    get {
      if case .configPacket(let v)? = _storage._payload {return v}
      return ConfigPacket()
    }
    set {_uniqueStorage()._payload = .configPacket(newValue)}
  }

  public var specialFunction: SpecialFunction {
    get {
      if case .specialFunction(let v)? = _storage._payload {return v}
      return SpecialFunction()
    }
    set {_uniqueStorage()._payload = .specialFunction(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case systemInfoPacket(SystemInfoPacket)
    case markPacket(MarkPacket)
    case configPacket(ConfigPacket)
    case specialFunction(SpecialFunction)

  #if !swift(>=4.1)
    public static func ==(lhs: Packet.OneOf_Payload, rhs: Packet.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.systemInfoPacket, .systemInfoPacket): return {
        guard case .systemInfoPacket(let l) = lhs, case .systemInfoPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.markPacket, .markPacket): return {
        guard case .markPacket(let l) = lhs, case .markPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configPacket, .configPacket): return {
        guard case .configPacket(let l) = lhs, case .configPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.specialFunction, .specialFunction): return {
        guard case .specialFunction(let l) = lhs, case .specialFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension SignalIdentifier: @unchecked Sendable {}
extension SensorAccuracy: @unchecked Sendable {}
extension MicSampleFreq: @unchecked Sendable {}
extension MicGain: @unchecked Sendable {}
extension MicBitResolution: @unchecked Sendable {}
extension CompressionType: @unchecked Sendable {}
extension PacketHeader: @unchecked Sendable {}
extension SimpleSensorReading: @unchecked Sendable {}
extension SensorReading: @unchecked Sendable {}
extension SensorReading.Payload: @unchecked Sendable {}
extension SensorConfig: @unchecked Sendable {}
extension SDCardState: @unchecked Sendable {}
extension MarkState: @unchecked Sendable {}
extension MarkPacket: @unchecked Sendable {}
extension BatteryState: @unchecked Sendable {}
extension Device: @unchecked Sendable {}
extension SystemInfoPacket: @unchecked Sendable {}
extension AudioCompression: @unchecked Sendable {}
extension AudioConfig: @unchecked Sendable {}
extension ScheduleConfig: @unchecked Sendable {}
extension LowPowerConfig: @unchecked Sendable {}
extension CameraControl: @unchecked Sendable {}
extension DeviceUID: @unchecked Sendable {}
extension NetworkState: @unchecked Sendable {}
extension ConfigPacket: @unchecked Sendable {}
extension PeerAddress: @unchecked Sendable {}
extension UWB_Range: @unchecked Sendable {}
extension UWB_Info: @unchecked Sendable {}
extension UWB_Packet: @unchecked Sendable {}
extension SpecialFunction: @unchecked Sendable {}
extension SpecialFunction.OneOf_Payload: @unchecked Sendable {}
extension Packet: @unchecked Sendable {}
extension Packet.OneOf_Payload: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension SignalIdentifier: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED"),
    1: .same(proto: "IAQ"),
    2: .same(proto: "STATIC_IAQ"),
    3: .same(proto: "CO2_EQ"),
    4: .same(proto: "BREATH_VOC_EQ"),
    6: .same(proto: "RAW_TEMPERATURE"),
    7: .same(proto: "RAW_PRESSURE"),
    8: .same(proto: "RAW_HUMIDITY"),
    9: .same(proto: "RAW_GAS"),
    12: .same(proto: "STABILIZATION_STATUS"),
    13: .same(proto: "RUN_IN_STATUS"),
    14: .same(proto: "SENSOR_HEAT_COMPEN_TEMP"),
    15: .same(proto: "HEAT_COMPEN_HUMID"),
    21: .same(proto: "GAS_PERCENTAGE"),
  ]
}

extension SensorAccuracy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNRELIABLE"),
    1: .same(proto: "LOW_ACCURACY"),
    2: .same(proto: "MEDIUM_ACCURACY"),
    3: .same(proto: "HIGH_ACCURACY"),
  ]
}

extension MicSampleFreq: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SAMPLE_RATE_8000"),
    1: .same(proto: "SAMPLE_RATE_11025"),
    2: .same(proto: "SAMPLE_RATE_16000"),
    3: .same(proto: "SAMPLE_RATE_22500"),
    4: .same(proto: "SAMPLE_RATE_24000"),
    5: .same(proto: "SAMPLE_RATE_32000"),
    6: .same(proto: "SAMPLE_RATE_44100"),
    7: .same(proto: "SAMPLE_RATE_48000"),
    8: .same(proto: "SAMPLE_RATE_96000"),
  ]
}

extension MicGain: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GAIN_60_DB"),
    1: .same(proto: "GAIN_57_DB"),
    2: .same(proto: "GAIN_54_DB"),
    3: .same(proto: "GAIN_51_DB"),
    4: .same(proto: "GAIN_48_DB"),
    5: .same(proto: "GAIN_45_DB"),
    6: .same(proto: "GAIN_42_DB"),
    7: .same(proto: "GAIN_39_DB"),
    8: .same(proto: "GAIN_36_DB"),
    9: .same(proto: "GAIN_33_DB"),
    10: .same(proto: "GAIN_30_DB"),
    11: .same(proto: "GAIN_27_DB"),
    12: .same(proto: "GAIN_24_DB"),
    13: .same(proto: "GAIN_21_DB"),
    14: .same(proto: "GAIN_18_DB"),
    15: .same(proto: "GAIN_15_DB"),
    16: .same(proto: "GAIN_12_DB"),
    17: .same(proto: "GAIN_9_DB"),
    18: .same(proto: "GAIN_6_DB"),
    19: .same(proto: "GAIN_3_DB"),
    20: .same(proto: "GAIN_0_DB"),
    21: .same(proto: "GAIN_NEG_3_DB"),
    22: .same(proto: "GAIN_NEG_6_DB"),
    23: .same(proto: "GAIN_NEG_9_DB"),
    24: .same(proto: "GAIN_NEG_12_DB"),
    25: .same(proto: "GAIN_NEG_15_DB"),
  ]
}

extension MicBitResolution: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BIT_RES_8"),
    1: .same(proto: "BIT_RES_16"),
    2: .same(proto: "BIT_RES_24"),
  ]
}

extension CompressionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPUS"),
    1: .same(proto: "FLAC"),
  ]
}

extension PacketHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PacketHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "system_uid"),
    2: .standard(proto: "ms_from_start"),
    3: .same(proto: "epoch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.systemUid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.msFromStart) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.epoch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.systemUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.systemUid, fieldNumber: 1)
    }
    if self.msFromStart != 0 {
      try visitor.visitSingularUInt32Field(value: self.msFromStart, fieldNumber: 2)
    }
    if self.epoch != 0 {
      try visitor.visitSingularUInt64Field(value: self.epoch, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PacketHeader, rhs: PacketHeader) -> Bool {
    if lhs.systemUid != rhs.systemUid {return false}
    if lhs.msFromStart != rhs.msFromStart {return false}
    if lhs.epoch != rhs.epoch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SimpleSensorReading: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SimpleSensorReading"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "timestamp_unix"),
    3: .same(proto: "temperature"),
    4: .same(proto: "humidity"),
    5: .same(proto: "co2"),
    6: .standard(proto: "light_level"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.timestampUnix) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.temperature) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.humidity) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.co2) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.lightLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.timestampUnix != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampUnix, fieldNumber: 2)
    }
    if self.temperature != 0 {
      try visitor.visitSingularFloatField(value: self.temperature, fieldNumber: 3)
    }
    if self.humidity != 0 {
      try visitor.visitSingularFloatField(value: self.humidity, fieldNumber: 4)
    }
    if self.co2 != 0 {
      try visitor.visitSingularFloatField(value: self.co2, fieldNumber: 5)
    }
    if self.lightLevel != 0 {
      try visitor.visitSingularFloatField(value: self.lightLevel, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SimpleSensorReading, rhs: SimpleSensorReading) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.timestampUnix != rhs.timestampUnix {return false}
    if lhs.temperature != rhs.temperature {return false}
    if lhs.humidity != rhs.humidity {return false}
    if lhs.co2 != rhs.co2 {return false}
    if lhs.lightLevel != rhs.lightLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorReading: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SensorReading"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packet_index"),
    2: .standard(proto: "sample_period"),
    3: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.packetIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.samplePeriod) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.packetIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.packetIndex, fieldNumber: 1)
    }
    if self.samplePeriod != 0 {
      try visitor.visitSingularUInt32Field(value: self.samplePeriod, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SensorReading, rhs: SensorReading) -> Bool {
    if lhs.packetIndex != rhs.packetIndex {return false}
    if lhs.samplePeriod != rhs.samplePeriod {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorReading.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = SensorReading.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_sensor"),
    2: .standard(proto: "timestamp_unix"),
    3: .standard(proto: "timestamp_ms_from_start"),
    4: .same(proto: "signal"),
    5: .standard(proto: "signal_dimensions"),
    6: .standard(proto: "sensor_id"),
    7: .same(proto: "accuracy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.timestampSensor) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.timestampUnix) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.timestampMsFromStart) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.signal) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.signalDimensions) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.sensorID) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.accuracy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestampSensor != 0 {
      try visitor.visitSingularFixed64Field(value: self.timestampSensor, fieldNumber: 1)
    }
    if self.timestampUnix != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestampUnix, fieldNumber: 2)
    }
    if self.timestampMsFromStart != 0 {
      try visitor.visitSingularUInt32Field(value: self.timestampMsFromStart, fieldNumber: 3)
    }
    if self.signal != 0 {
      try visitor.visitSingularFloatField(value: self.signal, fieldNumber: 4)
    }
    if self.signalDimensions != 0 {
      try visitor.visitSingularUInt32Field(value: self.signalDimensions, fieldNumber: 5)
    }
    if self.sensorID != .undefined {
      try visitor.visitSingularEnumField(value: self.sensorID, fieldNumber: 6)
    }
    if self.accuracy != .unreliable {
      try visitor.visitSingularEnumField(value: self.accuracy, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SensorReading.Payload, rhs: SensorReading.Payload) -> Bool {
    if lhs.timestampSensor != rhs.timestampSensor {return false}
    if lhs.timestampUnix != rhs.timestampUnix {return false}
    if lhs.timestampMsFromStart != rhs.timestampMsFromStart {return false}
    if lhs.signal != rhs.signal {return false}
    if lhs.signalDimensions != rhs.signalDimensions {return false}
    if lhs.sensorID != rhs.sensorID {return false}
    if lhs.accuracy != rhs.accuracy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SensorConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enable_temperature"),
    2: .standard(proto: "enable_humidity"),
    3: .standard(proto: "enable_gas"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enableTemperature) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enableHumidity) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.enableGas) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enableTemperature != false {
      try visitor.visitSingularBoolField(value: self.enableTemperature, fieldNumber: 1)
    }
    if self.enableHumidity != false {
      try visitor.visitSingularBoolField(value: self.enableHumidity, fieldNumber: 2)
    }
    if self.enableGas != false {
      try visitor.visitSingularBoolField(value: self.enableGas, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SensorConfig, rhs: SensorConfig) -> Bool {
    if lhs.enableTemperature != rhs.enableTemperature {return false}
    if lhs.enableHumidity != rhs.enableHumidity {return false}
    if lhs.enableGas != rhs.enableGas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SDCardState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SDCardState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "detected"),
    2: .standard(proto: "space_remaining"),
    3: .standard(proto: "estimated_remaining_recording_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.detected) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.spaceRemaining) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.estimatedRemainingRecordingTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.detected != false {
      try visitor.visitSingularBoolField(value: self.detected, fieldNumber: 1)
    }
    if self.spaceRemaining != 0 {
      try visitor.visitSingularUInt64Field(value: self.spaceRemaining, fieldNumber: 2)
    }
    if self.estimatedRemainingRecordingTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.estimatedRemainingRecordingTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SDCardState, rhs: SDCardState) -> Bool {
    if lhs.detected != rhs.detected {return false}
    if lhs.spaceRemaining != rhs.spaceRemaining {return false}
    if lhs.estimatedRemainingRecordingTime != rhs.estimatedRemainingRecordingTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MarkState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MarkState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mark_number"),
    2: .standard(proto: "timestamp_unix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.markNumber) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.timestampUnix) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.markNumber != 0 {
      try visitor.visitSingularUInt32Field(value: self.markNumber, fieldNumber: 1)
    }
    if self.timestampUnix != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestampUnix, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MarkState, rhs: MarkState) -> Bool {
    if lhs.markNumber != rhs.markNumber {return false}
    if lhs.timestampUnix != rhs.timestampUnix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MarkPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MarkPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "annotation"),
    2: .standard(proto: "beep_enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._annotation) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.beepEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._annotation {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if self.beepEnabled != false {
      try visitor.visitSingularBoolField(value: self.beepEnabled, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MarkPacket, rhs: MarkPacket) -> Bool {
    if lhs._annotation != rhs._annotation {return false}
    if lhs.beepEnabled != rhs.beepEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BatteryState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BatteryState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "charging"),
    2: .same(proto: "voltage"),
    3: .same(proto: "percentage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.charging) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.voltage) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._percentage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.charging != false {
      try visitor.visitSingularBoolField(value: self.charging, fieldNumber: 1)
    }
    if self.voltage != 0 {
      try visitor.visitSingularFloatField(value: self.voltage, fieldNumber: 2)
    }
    try { if let v = self._percentage {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BatteryState, rhs: BatteryState) -> Bool {
    if lhs.charging != rhs.charging {return false}
    if lhs.voltage != rhs.voltage {return false}
    if lhs._percentage != rhs._percentage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Device"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UID"),
    2: .same(proto: "range"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.range) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularUInt32Field(value: self.uid, fieldNumber: 1)
    }
    if self.range != 0 {
      try visitor.visitSingularUInt32Field(value: self.range, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Device, rhs: Device) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.range != rhs.range {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SystemInfoPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SystemInfoPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "simple_sensor_reading"),
    2: .standard(proto: "device_recording"),
    3: .standard(proto: "sdcard_state"),
    4: .standard(proto: "mark_state"),
    5: .standard(proto: "battery_state"),
    6: .same(proto: "discoveredDevices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._simpleSensorReading) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.deviceRecording) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sdcardState) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._markState) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._batteryState) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.discoveredDevices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._simpleSensorReading {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.deviceRecording != false {
      try visitor.visitSingularBoolField(value: self.deviceRecording, fieldNumber: 2)
    }
    try { if let v = self._sdcardState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._markState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._batteryState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.discoveredDevices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.discoveredDevices, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SystemInfoPacket, rhs: SystemInfoPacket) -> Bool {
    if lhs._simpleSensorReading != rhs._simpleSensorReading {return false}
    if lhs.deviceRecording != rhs.deviceRecording {return false}
    if lhs._sdcardState != rhs._sdcardState {return false}
    if lhs._markState != rhs._markState {return false}
    if lhs._batteryState != rhs._batteryState {return false}
    if lhs.discoveredDevices != rhs.discoveredDevices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AudioCompression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AudioCompression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "compression_type"),
    3: .standard(proto: "compression_factor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.compressionType) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.compressionFactor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.compressionType != .opus {
      try visitor.visitSingularEnumField(value: self.compressionType, fieldNumber: 2)
    }
    if self.compressionFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.compressionFactor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AudioCompression, rhs: AudioCompression) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.compressionType != rhs.compressionType {return false}
    if lhs.compressionFactor != rhs.compressionFactor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AudioConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AudioConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_1"),
    2: .standard(proto: "channel_2"),
    3: .standard(proto: "sample_freq"),
    4: .standard(proto: "mic_gain"),
    5: .standard(proto: "bit_resolution"),
    6: .standard(proto: "audio_compression"),
    7: .standard(proto: "estimated_record_time"),
    8: .standard(proto: "free_run_mode"),
    9: .standard(proto: "chirp_enable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.channel1) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.channel2) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.sampleFreq) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.micGain) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.bitResolution) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._audioCompression) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.estimatedRecordTime) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.freeRunMode) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.chirpEnable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.channel1 != false {
      try visitor.visitSingularBoolField(value: self.channel1, fieldNumber: 1)
    }
    if self.channel2 != false {
      try visitor.visitSingularBoolField(value: self.channel2, fieldNumber: 2)
    }
    if self.sampleFreq != .sampleRate8000 {
      try visitor.visitSingularEnumField(value: self.sampleFreq, fieldNumber: 3)
    }
    if self.micGain != .gain60Db {
      try visitor.visitSingularEnumField(value: self.micGain, fieldNumber: 4)
    }
    if self.bitResolution != .bitRes8 {
      try visitor.visitSingularEnumField(value: self.bitResolution, fieldNumber: 5)
    }
    try { if let v = self._audioCompression {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.estimatedRecordTime != 0 {
      try visitor.visitSingularFloatField(value: self.estimatedRecordTime, fieldNumber: 7)
    }
    if self.freeRunMode != false {
      try visitor.visitSingularBoolField(value: self.freeRunMode, fieldNumber: 8)
    }
    if self.chirpEnable != false {
      try visitor.visitSingularBoolField(value: self.chirpEnable, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AudioConfig, rhs: AudioConfig) -> Bool {
    if lhs.channel1 != rhs.channel1 {return false}
    if lhs.channel2 != rhs.channel2 {return false}
    if lhs.sampleFreq != rhs.sampleFreq {return false}
    if lhs.micGain != rhs.micGain {return false}
    if lhs.bitResolution != rhs.bitResolution {return false}
    if lhs._audioCompression != rhs._audioCompression {return false}
    if lhs.estimatedRecordTime != rhs.estimatedRecordTime {return false}
    if lhs.freeRunMode != rhs.freeRunMode {return false}
    if lhs.chirpEnable != rhs.chirpEnable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ScheduleConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ScheduleConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Sunday"),
    2: .same(proto: "Monday"),
    3: .same(proto: "Tuesday"),
    4: .same(proto: "Wednesday"),
    5: .same(proto: "Thursday"),
    6: .same(proto: "Friday"),
    7: .same(proto: "Saturday"),
    8: .standard(proto: "start_hour"),
    9: .standard(proto: "start_minute"),
    10: .standard(proto: "stop_hour"),
    11: .standard(proto: "stop_minute"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.sunday) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.monday) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.tuesday) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.wednesday) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.thursday) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.friday) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.saturday) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.startHour) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.startMinute) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.stopHour) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.stopMinute) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sunday != false {
      try visitor.visitSingularBoolField(value: self.sunday, fieldNumber: 1)
    }
    if self.monday != false {
      try visitor.visitSingularBoolField(value: self.monday, fieldNumber: 2)
    }
    if self.tuesday != false {
      try visitor.visitSingularBoolField(value: self.tuesday, fieldNumber: 3)
    }
    if self.wednesday != false {
      try visitor.visitSingularBoolField(value: self.wednesday, fieldNumber: 4)
    }
    if self.thursday != false {
      try visitor.visitSingularBoolField(value: self.thursday, fieldNumber: 5)
    }
    if self.friday != false {
      try visitor.visitSingularBoolField(value: self.friday, fieldNumber: 6)
    }
    if self.saturday != false {
      try visitor.visitSingularBoolField(value: self.saturday, fieldNumber: 7)
    }
    if self.startHour != 0 {
      try visitor.visitSingularUInt32Field(value: self.startHour, fieldNumber: 8)
    }
    if self.startMinute != 0 {
      try visitor.visitSingularUInt32Field(value: self.startMinute, fieldNumber: 9)
    }
    if self.stopHour != 0 {
      try visitor.visitSingularUInt32Field(value: self.stopHour, fieldNumber: 10)
    }
    if self.stopMinute != 0 {
      try visitor.visitSingularUInt32Field(value: self.stopMinute, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ScheduleConfig, rhs: ScheduleConfig) -> Bool {
    if lhs.sunday != rhs.sunday {return false}
    if lhs.monday != rhs.monday {return false}
    if lhs.tuesday != rhs.tuesday {return false}
    if lhs.wednesday != rhs.wednesday {return false}
    if lhs.thursday != rhs.thursday {return false}
    if lhs.friday != rhs.friday {return false}
    if lhs.saturday != rhs.saturday {return false}
    if lhs.startHour != rhs.startHour {return false}
    if lhs.startMinute != rhs.startMinute {return false}
    if lhs.stopHour != rhs.stopHour {return false}
    if lhs.stopMinute != rhs.stopMinute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LowPowerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LowPowerConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lowPowerMode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.lowPowerMode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lowPowerMode != false {
      try visitor.visitSingularBoolField(value: self.lowPowerMode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LowPowerConfig, rhs: LowPowerConfig) -> Bool {
    if lhs.lowPowerMode != rhs.lowPowerMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CameraControl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CameraControl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pair_with_nearby_cameras"),
    2: .standard(proto: "wakeup_cameras"),
    3: .same(proto: "capture"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.pairWithNearbyCameras) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.wakeupCameras) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.capture) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pairWithNearbyCameras != false {
      try visitor.visitSingularBoolField(value: self.pairWithNearbyCameras, fieldNumber: 1)
    }
    if self.wakeupCameras != false {
      try visitor.visitSingularBoolField(value: self.wakeupCameras, fieldNumber: 2)
    }
    if self.capture != false {
      try visitor.visitSingularBoolField(value: self.capture, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CameraControl, rhs: CameraControl) -> Bool {
    if lhs.pairWithNearbyCameras != rhs.pairWithNearbyCameras {return false}
    if lhs.wakeupCameras != rhs.wakeupCameras {return false}
    if lhs.capture != rhs.capture {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceUID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DeviceUID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DeviceUID, rhs: DeviceUID) -> Bool {
    if lhs.addr != rhs.addr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NetworkState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NetworkState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "number_of_discovered_devices"),
    2: .standard(proto: "discovered_device_UID"),
    3: .same(proto: "channel"),
    4: .same(proto: "panID"),
    5: .same(proto: "slaveSync"),
    6: .same(proto: "masterNode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.numberOfDiscoveredDevices) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.discoveredDeviceUid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.channel) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.panID) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.slaveSync) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.masterNode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numberOfDiscoveredDevices != 0 {
      try visitor.visitSingularUInt32Field(value: self.numberOfDiscoveredDevices, fieldNumber: 1)
    }
    if !self.discoveredDeviceUid.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.discoveredDeviceUid, fieldNumber: 2)
    }
    if self.channel != 0 {
      try visitor.visitSingularUInt32Field(value: self.channel, fieldNumber: 3)
    }
    if self.panID != 0 {
      try visitor.visitSingularUInt32Field(value: self.panID, fieldNumber: 4)
    }
    if self.slaveSync != false {
      try visitor.visitSingularBoolField(value: self.slaveSync, fieldNumber: 5)
    }
    if self.masterNode != false {
      try visitor.visitSingularBoolField(value: self.masterNode, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NetworkState, rhs: NetworkState) -> Bool {
    if lhs.numberOfDiscoveredDevices != rhs.numberOfDiscoveredDevices {return false}
    if lhs.discoveredDeviceUid != rhs.discoveredDeviceUid {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.panID != rhs.panID {return false}
    if lhs.slaveSync != rhs.slaveSync {return false}
    if lhs.masterNode != rhs.masterNode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConfigPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ConfigPacket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_config"),
    2: .standard(proto: "schedule_config"),
    3: .standard(proto: "sensor_config"),
    4: .standard(proto: "low_power_config"),
    5: .standard(proto: "network_state"),
    6: .standard(proto: "enable_recording"),
    7: .standard(proto: "enable_led"),
  ]

  fileprivate class _StorageClass {
    var _audioConfig: AudioConfig? = nil
    var _scheduleConfig: [ScheduleConfig] = []
    var _sensorConfig: SensorConfig? = nil
    var _lowPowerConfig: LowPowerConfig? = nil
    var _networkState: NetworkState? = nil
    var _enableRecording: Bool = false
    var _enableLed: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _audioConfig = source._audioConfig
      _scheduleConfig = source._scheduleConfig
      _sensorConfig = source._sensorConfig
      _lowPowerConfig = source._lowPowerConfig
      _networkState = source._networkState
      _enableRecording = source._enableRecording
      _enableLed = source._enableLed
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._audioConfig) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._scheduleConfig) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._sensorConfig) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._lowPowerConfig) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._networkState) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._enableRecording) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._enableLed) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._audioConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._scheduleConfig.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._scheduleConfig, fieldNumber: 2)
      }
      try { if let v = _storage._sensorConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._lowPowerConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._networkState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._enableRecording != false {
        try visitor.visitSingularBoolField(value: _storage._enableRecording, fieldNumber: 6)
      }
      if _storage._enableLed != false {
        try visitor.visitSingularBoolField(value: _storage._enableLed, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ConfigPacket, rhs: ConfigPacket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._audioConfig != rhs_storage._audioConfig {return false}
        if _storage._scheduleConfig != rhs_storage._scheduleConfig {return false}
        if _storage._sensorConfig != rhs_storage._sensorConfig {return false}
        if _storage._lowPowerConfig != rhs_storage._lowPowerConfig {return false}
        if _storage._networkState != rhs_storage._networkState {return false}
        if _storage._enableRecording != rhs_storage._enableRecording {return false}
        if _storage._enableLed != rhs_storage._enableLed {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PeerAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PeerAddress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pan_id"),
    2: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.panID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.panID != 0 {
      try visitor.visitSingularUInt32Field(value: self.panID, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PeerAddress, rhs: PeerAddress) -> Bool {
    if lhs.panID != rhs.panID {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UWB_Range: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UWB_Range"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "openthread_UID"),
    2: .standard(proto: "system_UID"),
    3: .standard(proto: "UWB_addr"),
    4: .same(proto: "range"),
    5: .same(proto: "stdDev"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._openthreadUid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.systemUid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._uwbAddr) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.range) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.stdDev) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._openthreadUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.systemUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.systemUid, fieldNumber: 2)
    }
    try { if let v = self._uwbAddr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.range != 0 {
      try visitor.visitSingularUInt32Field(value: self.range, fieldNumber: 4)
    }
    if self.stdDev != 0 {
      try visitor.visitSingularFloatField(value: self.stdDev, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UWB_Range, rhs: UWB_Range) -> Bool {
    if lhs._openthreadUid != rhs._openthreadUid {return false}
    if lhs.systemUid != rhs.systemUid {return false}
    if lhs._uwbAddr != rhs._uwbAddr {return false}
    if lhs.range != rhs.range {return false}
    if lhs.stdDev != rhs.stdDev {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UWB_Info: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UWB_Info"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "openthread_UID"),
    2: .standard(proto: "system_UID"),
    3: .standard(proto: "UWB_addr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._openthreadUid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.systemUid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._uwbAddr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._openthreadUid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.systemUid != 0 {
      try visitor.visitSingularUInt32Field(value: self.systemUid, fieldNumber: 2)
    }
    try { if let v = self._uwbAddr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UWB_Info, rhs: UWB_Info) -> Bool {
    if lhs._openthreadUid != rhs._openthreadUid {return false}
    if lhs.systemUid != rhs.systemUid {return false}
    if lhs._uwbAddr != rhs._uwbAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UWB_Packet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UWB_Packet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startRanging"),
    2: .same(proto: "turnOnUWB"),
    3: .same(proto: "ranges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.startRanging) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.turnOnUwb) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.ranges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startRanging != false {
      try visitor.visitSingularBoolField(value: self.startRanging, fieldNumber: 1)
    }
    if self.turnOnUwb != false {
      try visitor.visitSingularBoolField(value: self.turnOnUwb, fieldNumber: 2)
    }
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UWB_Packet, rhs: UWB_Packet) -> Bool {
    if lhs.startRanging != rhs.startRanging {return false}
    if lhs.turnOnUwb != rhs.turnOnUwb {return false}
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpecialFunction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SpecialFunction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "format_sdcard"),
    2: .standard(proto: "camera_control"),
    3: .standard(proto: "uwb_packet"),
    4: .standard(proto: "openthread_sync_time"),
    5: .standard(proto: "mag_calibration"),
    6: .standard(proto: "slave_req_config"),
    7: .same(proto: "timestamp"),
    8: .standard(proto: "dfu_mode"),
    9: .standard(proto: "uwb_info"),
    10: .standard(proto: "reset_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .formatSdcard(v)
        }
      }()
      case 2: try {
        var v: CameraControl?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .cameraControl(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .cameraControl(v)
        }
      }()
      case 3: try {
        var v: UWB_Packet?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .uwbPacket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .uwbPacket(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .openthreadSyncTime(v)
        }
      }()
      case 5: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .magCalibration(v)
        }
      }()
      case 6: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .slaveReqConfig(v)
        }
      }()
      case 7: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .timestamp(v)
        }
      }()
      case 8: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .dfuMode(v)
        }
      }()
      case 9: try {
        var v: UWB_Info?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .uwbInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .uwbInfo(v)
        }
      }()
      case 10: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .resetConfig(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .formatSdcard?: try {
      guard case .formatSdcard(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .cameraControl?: try {
      guard case .cameraControl(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .uwbPacket?: try {
      guard case .uwbPacket(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .openthreadSyncTime?: try {
      guard case .openthreadSyncTime(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case .magCalibration?: try {
      guard case .magCalibration(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }()
    case .slaveReqConfig?: try {
      guard case .slaveReqConfig(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }()
    case .timestamp?: try {
      guard case .timestamp(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }()
    case .dfuMode?: try {
      guard case .dfuMode(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }()
    case .uwbInfo?: try {
      guard case .uwbInfo(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .resetConfig?: try {
      guard case .resetConfig(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SpecialFunction, rhs: SpecialFunction) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Packet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Packet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .standard(proto: "system_info_packet"),
    3: .standard(proto: "mark_packet"),
    4: .standard(proto: "config_packet"),
    5: .standard(proto: "special_function"),
  ]

  fileprivate class _StorageClass {
    var _header: PacketHeader? = nil
    var _payload: Packet.OneOf_Payload?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 2: try {
          var v: SystemInfoPacket?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .systemInfoPacket(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .systemInfoPacket(v)
          }
        }()
        case 3: try {
          var v: MarkPacket?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .markPacket(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .markPacket(v)
          }
        }()
        case 4: try {
          var v: ConfigPacket?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .configPacket(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .configPacket(v)
          }
        }()
        case 5: try {
          var v: SpecialFunction?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .specialFunction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .specialFunction(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      switch _storage._payload {
      case .systemInfoPacket?: try {
        guard case .systemInfoPacket(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .markPacket?: try {
        guard case .markPacket(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .configPacket?: try {
        guard case .configPacket(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .specialFunction?: try {
        guard case .specialFunction(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Packet, rhs: Packet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
